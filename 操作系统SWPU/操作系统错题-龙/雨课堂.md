## <font color='red'>单元小练雨课堂</font>
##### 文件管理
目录和目录文件，于实现父子文件夹的探讨
	目录是最终呈现给用户的，其实现**本质是通过目录文件实现**
	所以文件的各种属性存放在目录中，**也即**相当于说存放在目录文件中

5=>**文件管理属于外存管理**

##### 第二章 进程基础和线程
 <font color='red'>测试2  进程基础</font>
- 1某单处理器系统中若同时存在5个进程,则处于**等待**状态的进程最多可有(   )个。
- 6某处理器有4个核,目前系统中若同时存在6个进程,则处于**运行**状态的进程最多/最少可有( )个。
	处于等待状态max  n
	处于就绪状态max  n-x(根据**cpu核心数量x**决定最多同时运行进程)

9**进程被唤醒：从等待队列到就绪队列**
**10原语的主要特点：不可分割性**

 <font color='red'>测试4 进程同步</font>
**1 存在忙等的信号量是整型信号量**
- [ ] 4系统中有10个并发进程涉及某个相同的变量A,则变量A的相关临界区最少有( 10)个。

>[!临界区]
>[临界区、相关临界区_相关临界区个数怎么计算-CSDN博客](https://blog.csdn.net/weixin_36340947/article/details/78179263?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522461784e3e9f0709358b9f5a09b4594de%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=461784e3e9f0709358b9f5a09b4594de&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-78179263-null-null.142^v102^pc_search_result_base5&utm_term=%E4%B8%B4%E7%95%8C%E5%8C%BA%E3%80%81%E7%9B%B8%E5%85%B3%E4%B8%B4%E7%95%8C%E5%8C%BA&spm=1018.2226.3001.4187)
 **临界区**：**每个进程中**访问临界资源的那段代码称为临界区（Critical Section）
 **临界资源**：临界资源是一次仅允许一个进程使用的共享资源
  ==相关临界区==：多个进程中涉及到同一个临界资源的临界区称为相关临界区
  理解：
  **每个进程**的都有一个访问临界资源A的**临界区**代码，由同一个**全局互斥信号量**mutex保护，所有的这些访问a的临界区共同构成一个**相关临界区**。
   <font color='red'>同一时间仅允许一个进程进入其临界区代码</font>
```c
class ThreadSafeCounter {
    int count = 0;
    semaphore mutex = 1;
public:
    void increment() {
        wait(mutex);
        count++;  // 临界区
        signal(mutex);
    }
    int get() {
        wait(mutex);
        int ret = count;  // 读操作也需同步
        signal(mutex);
        return ret;
    }
};increment() 和 get() 中的两临界区共同构成一个相关临界区，由同一个 mutex 保护。
```


5 有m个进程共享同一临界资源,若使用信号量机制实现对这一临界资源的互斥访问,则信号量的变化范围是(-(m-1 ~1)。
	**信号量选择**：**记录形信号量**。整形信号量由于其**忙等**的缺点以及**无法负值表示等待进程量**，**被**既可以用正值表示资源数量，还可以用负值表示等待的**信号量的记录型替代**


##### 第三章 处理机调度与死锁
<font color='red'>测试5 调度</font>
4从进程提交到**首次**运行的时间段,称为( **响应时间**)。
>[!调度时间]
**等待时间**=周转时间-到达时间=全过程**所有**等待时间(包括抢占后的等待时间等)
周转时间=结束时间-到达时间=等待时间+运行时间
带权周转时间=周转时间/运行时间
HRRN最高响应比优先算法，**响应比**=周转时间/运行时间=1+**等待时间/运行时间**

<font color='red'>测试6 死锁</font>
1某系统采用了银行家算法,则下列说法正确的是(  系统处于不安全状态可能死锁 )。

>[!安全状态与死锁]
>安全状态：系统存在**至少一个**进程执行序列，使得所有进程都能顺利完成
>不安全状态：系统**不存在**此进程执行序列
><font color='red'>但是不安全状态不等于发生发送死锁，我们可以释放资源以回溯</font>
>安全状态 -->|错误分配| 不安全状态
>不安全状态 -->|继续不当请求| 死锁
>     不安全状态 -->|**释放资源**| 安全状态

4以下( 剥夺死锁进程资源   )方法可以解除死锁。
>[!死锁避免]
>死锁：互斥条件，不剥夺条件，请求保持条件，环路条件**缺一不可**。
>**死锁发生前**
>1==预防==死锁：设置限制条件（**破坏四条件之一**，如有序资源分配法）
>2==避免==死锁：如银行家算法
>**死锁发生后**
>3==检测死锁加解除==死锁：解除死锁一般为
>（1）**回退**或者**终止**死锁进程以释放其资源
>（2）**剥夺**死锁进程资源

6设某类资源有5个,由3个进程共享,要使系统不会死锁则每个进程最多可申请的资源数是(  2 ) 。
	**5/3=1...2**那么每个进程最多申请2个才能保证不死锁

7某系统中有3个并发进程,都需要同类资源4个,该系统不会发生死锁的最少资源数是(   10)。
	**3*(4-1)=9,  9+1=10**，**在都差一个资源的基础上加一个**就可以保证在不死锁的可以下完成所有进程