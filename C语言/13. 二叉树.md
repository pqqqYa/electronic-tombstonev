# 13. 二叉树

## 13.1 树


*  `Tree`树是n(n>0)个节点的有限集。
* 当n=0时，称为空树。
* 在任意一棵非空树中应满足:
	1. 有且仅有一个特定的称为根的结点。
	2. 当n>1时，其余节点可分为m(m>0)个互不相交的有限集T1,T2... Tm，其中每个集合本身又是一棵树，并且称为根的子树。
* 树作为一种逻辑结构，同时也是一种分层结构
	1. 树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。
	2. 树中所有结点可以有零个或多个后继

![[树的结构.png]]

## 13.2 二叉树

* 二叉树是一种树形结构
* 每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点，度指的是结点的分叉的数量）
* 二又树的子树有左右之分，其次序不能任意颠倒。
* 与树相似，二又树也以递归的形式定义。二树是n(n≥0)个结点的有限集合
	1. 或者为空二又树，即n=0。
	2. 或者由一个根结点和两个五不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。

![[二叉树的结构.png]]

* 满二叉树：每一层的个数就是$2^{n-1}$个结点
* 完全二叉树：从左往右依次填充满了再填充下一层的二叉树

### 13.2.1 二叉树的顺序存储

![[二叉树的顺序存储.png]]

### 13.2.2二叉树的链式存储

![[二叉树的链式存储.png]]

~~~cpp
typedef char BiElemType,
typedef struct BiTNodef
	BiElemType data;       //数据段
	struct BiTNode *lchild://左指针
	struct BiTNode *rchild://右指针
}BiTNode,*BiTree,
~~~

### 13.2.3二叉树层次建树实例

使用辅助队列

1. 在元素放入二叉树前，先~~放入~~辅助队列（这里辅助队列的data段直接存放树的结点的地址值，因为这里不需要对元素进行操作）
2. `pcur`指针指向第一个放入的元素
3. 放入第二个元素，判断`pcur`指针指向的元素即第一个元素，左右结点是否为空，优先放入左节点
4. 当第一个元素放满，`pcur`指针指向第二个元素
5. 队列放入第四个元素，判断`pcur`指针指向的元素即第二个元素，左右结点是否为空，优先放入左节点
6. 辅助队列`pcur`指针不断向后移动

使用calloc申请的空间

* `(StructName *)calloc(NumOfElement,SizeOfElement)`
* 申请的空间大小是2个参数的大小直接相乘
* 会对对空间进行初始化，**赋值为0(NULL)**
* 这里使用可以直接对所有树中的二叉树进行初始化，不用在每次申请完成后

~~~cpp
#ifndef FUNCTION_H  
#define FUNCTION_H  
 
#include <stdio.h>  
#include <stdlib.h>  
typedef char BiElemType;  
typedef struct BiTNode{  
    BiElemType data;  
    struct BiTNode *lchild, *rchild;  
}BiTNode, *BiTree;  
  
typedef struct tag  
{  
    BiTree p;  
    struct tag *pnext;  
}tag_t, *ptag_t;  
  
#endif //FUNCTION_H
~~~

~~~cpp
#include "function.h"  
int main()  
{  
    BiTree pnew;//用来指向新申请的树结点  
    BiTree tree=NULL;//tree指向树根的，代表树  
    BiElemType data;  
    ptag_t phead=NULL,ptail=NULL,list_pnew=NULL,pcur;  
    while (scanf("%c", &data))  
    {  
        if (data == '\n')  
        {  
            break;  
        }  
        //calloc申请的空间大小是2个参数的大小直接相乘，并对空间进行初始化，赋值为0(NULL)  
        pnew = (BiTree)calloc(1,sizeof(BiTNode));  
        pnew->data = data;  
        list_pnew = (ptag_t)calloc(1,sizeof(tag_t));  
        list_pnew->p = pnew;  
        //如果是树的第一个结点  
        if (tree == NULL)  
        {  
            tree = pnew;  
            phead = list_pnew;//第一个结点既是队列头，也是队列尾  
            ptail = list_pnew;  
            pcur = list_pnew;//pcur要指向要进入树的父亲元素  
        }else  
        {  
            //先让元素入列  
            ptail->pnext = list_pnew;  
            ptail = list_pnew;  
            //把接下来的结点放入树中  
            if (pcur->p->lchild == NULL)  
            {  
                pcur->p->lchild = pnew;  
            }else if (pcur->p->rchild == NULL)  
            {  
                pcur->p->rchild = pnew;  
                pcur = pcur->pnext;//放入右节点后，当前结点已满，pcur指向下一个结点  
            }  
        }  
    }  
  
    return 0;  
}
~~~

### 13.2.4 二叉树的遍历

* 前序遍历（先序遍历，深度优先遍历）：递归，先打印自身，后打印左子树，再打印右子树
* 中序遍历：递归，先打印左子树，后打印当前结点，再打印右子树
* 后序遍历：递归，先打印左子树，后打印右子树，最后打印当前节点
* 层次遍历：

前序遍历实例


~~~cpp
~~~

中序遍历实例

~~~cpp
~~~

后序遍历实例

~~~cpp
~~~
