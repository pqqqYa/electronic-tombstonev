# 13. 二叉树

## 13.1 树


*  `Tree`树是n(n>0)个节点的有限集。
* 当n=0时，称为空树。
* 在任意一棵非空树中应满足:
	1. 有且仅有一个特定的称为根的结点。
	2. 当n>1时，其余节点可分为m(m>0)个互不相交的有限集T1,T2... Tm，其中每个集合本身又是一棵树，并且称为根的子树。
* 树作为一种逻辑结构，同时也是一种分层结构
	1. 树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。
	2. 树中所有结点可以有零个或多个后继

![[树的结构.png]]

## 13.2 二叉树

* 二叉树是一种树形结构
* 每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点，度指的是结点的分叉的数量）
* 二又树的子树有左右之分，其次序不能任意颠倒。
* 与树相似，二又树也以递归的形式定义。二树是n(n≥0)个结点的有限集合
	1. 或者为空二又树，即n=0。
	2. 或者由一个根结点和两个五不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。

![[二叉树的结构.png]]

* 满二叉树：每一层的个数就是$2^{n-1}$个结点
* 完全二叉树：从左往右依次填充满了再填充下一层的二叉树

### 13.2.1 二叉树的顺序存储

![[二叉树的顺序存储.png]]

### 13.2.2二叉树的链式存储

![[二叉树的链式存储.png]]

~~~cpp
typedef char BiElemType,
typedef struct BiTNodef
	BiElemType data;       //数据段
	struct BiTNode *lchild://左指针
	struct BiTNode *rchild://右指针
}BiTNode,*BiTree,
~~~

### 13.2.3二叉树层次建树实例

使用辅助队列

1. 在元素放入二叉树前，先~~放入~~辅助队列（这里辅助队列的data段直接存放树的结点的地址值，因为这里不需要对元素进行操作）
2. `pcur`指针指向第一个放入的元素
3. 放入第二个元素，判断`pcur`指针指向的元素即第一个元素，左右结点是否为空，优先放入左节点
4. 当第一个元素放满，`pcur`指针指向第二个元素
5. 队列放入第四个元素，判断`pcur`指针指向的元素即第二个元素，左右结点是否为空，优先放入左节点
6. 辅助队列`pcur`指针不断向后移动

使用calloc申请的空间

* `(StructName *)calloc(NumOfElement,SizeOfElement)`
* 申请的空间大小是2个参数的大小直接相乘
* 会对对空间进行初始化，**赋值为0(NULL)**
* 这里使用可以直接对所有树中的二叉树进行初始化，不用在每次申请完成后

~~~cpp
#ifndef FUNCTION_H  
#define FUNCTION_H  
 
#include <stdio.h>  
#include <stdlib.h>  
typedef char BiElemType;  
typedef struct BiTNode{  
    BiElemType data;  
    struct BiTNode *lchild, *rchild;  
}BiTNode, *BiTree;  
//tag结构体是辅助队列使用的
typedef struct tag  
{  
    BiTree p;  //树的某一个结点的地址值
    struct tag *pnext;  
}tag_t, *ptag_t;  
  
#endif //FUNCTION_H
~~~

~~~cpp
#include "function.h"  
int main()  
{  
    BiTree pnew;//用来指向新申请的树结点  
    BiTree tree=NULL;//tree指向树根的，代表树  
    BiElemType data;  
    ptag_t phead=NULL,ptail=NULL,list_pnew=NULL,pcur;  
    while (scanf("%c", &data))  
    {  
        if (data == '\n')  
        {  
            break;  
        }  
        //calloc申请的空间大小是2个参数的大小直接相乘，并对空间进行初始化，赋值为0(NULL)  
        pnew = (BiTree)calloc(1,sizeof(BiTNode));  
        pnew->data = data;  
        list_pnew = (ptag_t)calloc(1,sizeof(tag_t));  
        list_pnew->p = pnew;  
        //如果是树的第一个结点  
        if (tree == NULL)  
        {  
            tree = pnew;  
            phead = list_pnew;//第一个结点既是队列头，也是队列尾  
            ptail = list_pnew;  
            pcur = list_pnew;//pcur要指向要进入树的父亲元素  
        }else  
        {  
            //先让元素入列  
            ptail->pnext = list_pnew;  
            ptail = list_pnew;  
            //把接下来的结点放入树中  
            if (pcur->p->lchild == NULL)  
            {  
                pcur->p->lchild = pnew;  
            }else if (pcur->p->rchild == NULL)  
            {  
                pcur->p->rchild = pnew;  
                pcur = pcur->pnext;//放入右节点后，当前结点已满，pcur指向下一个结点  
            }  
        }  
    }  
  
    return 0;  
}
~~~

### 13.2.4 二叉树的遍历

* 前序遍历（先序遍历，深度优先遍历）：递归，先打印自身，后打印左子树，再打印右子树
* 中序遍历：递归，先打印左子树，后打印当前结点，再打印右子树
* 后序遍历：递归，先打印左子树，后打印右子树，最后打印当前节点
* 层次遍历（广度优先遍历）：使用辅助队列，借助

前序遍历实例（使用13.2.3的建树代码）

~~~cpp
void PreOrder(BiTree p)  
{  
  
    if (p!=NULL)  
    {  
        printf("%c", p->data);  
        PreOrder(p->lchild);//打印左子树  
        PreOrder(p->rchild);//打印右子树  
    }  
}  
~~~

中序遍历实例（使用13.2.3的建树代码）

~~~cpp
void InOrder(BiTree p)  
{  
    if (p!=NULL)  
    {  
        InOrder(p->lchild);//打印左子树  
        printf("%c", p->data);  
        InOrder(p->rchild);//打印右子树  
    }  
}  
~~~

后序遍历实例（使用13.2.3的建树代码）

~~~cpp
void PostOrder(BiTree p)  
{  
    if (p!=NULL)  
    {  
        PostOrder(p->lchild);//打印左子树  
        PostOrder(p->rchild);//打印右子树  
        printf("%c", p->data);  
    }  
}
~~~

层次遍历，广度优先遍历实例（`function.h`，`queue.cpp`，`main.cpp`）

~~~cpp
#ifndef FUNCTION_H  
#define FUNCTION_H  
  
#include <stdio.h>  
#include <stdlib.h>  
  
typedef char BiElemType;  
  
typedef struct BiTNode{  
    BiElemType data;  
    struct BiTNode *lchild, *rchild;  
}BiTNode, *BiTree;  
  
//tag结构体是辅助队列使用的  
typedef struct tag  
{  
    BiTree p;  //树的某一个结点的地址值  
    struct tag *pnext;  
}tag_t, *ptag_t;  
  
//队列的链式存储的结构体  
typedef BiTree ElemType;  
  
typedef struct LinkNode{  
    ElemType data;  
    struct LinkNode *next;  
}LinkNode;  
typedef struct{  
    LinkNode *front, *rear ;//链表头，链表尾  
}LinkQueue ;//先进先出  
  
void InitQueue(LinkQueue &);  
bool IsEmpty(LinkQueue q);  
void EnQueue (LinkQueue &Q, ElemType x);  
bool DeQueue (LinkQueue &Q, ElemType &x);  
  
  
#endif //FUNCTION_H
~~~

~~~cpp
#include "function.h"  
//初始化队列  
void InitQueue(LinkQueue &Q)  
{  
    Q.front=Q.rear=(LinkNode*)malloc(sizeof(LinkNode));//头和尾指向同一个结点  
    Q.front->next=NULL;//头结点的 next 指针为 NULL}  
//判断队列是否为空  
bool IsEmpty(LinkQueue Q)  
{  
    return Q.front==Q.rear;  
}  
//入队,尾部插入法  
void EnQueue(LinkQueue &Q,ElemType x)  
{  
    LinkNode *s=(LinkNode *)malloc(sizeof(LinkNode));  
    s->data=x;s->next=NULL;  
    Q.rear->next=s;//rear 始终指向尾部  
    Q.rear=s;  
}  
//出队,头部删除法  
bool DeQueue(LinkQueue &Q,ElemType &x)  
{  
    if(Q.front==Q.rear)  
    {  
        return false;//队列为空  
    }  
    LinkNode *p=Q.front->next;//头结点什么都没存，所以头结点的下一个节点才有数据  
    x=p->data;  
    Q.front->next=p->next;//断链  
    if(Q.rear==p)//删除的是最后一个元素  
    {  
        Q.rear=Q.front;//队列置为空  
    }  
    free(p);  
    return true;  
}
~~~

~~~cpp
#include "function.h"  
//前序遍历
void PreOrder(BiTree p)  
{  
  
    if (p!=NULL)  
    {  
        printf("%c", p->data);  
        PreOrder(p->lchild);//打印左子树  
        PreOrder(p->rchild);//打印右子树  
    }  
}  
//中序遍历
void InOrder(BiTree p)  
{  
    if (p!=NULL)  
    {  
        InOrder(p->lchild);//打印左子树  
        printf("%c", p->data);  
        InOrder(p->rchild);//打印右子树  
    }  
}  
//后序遍历
void PostOrder(BiTree p)  
{  
    if (p!=NULL)  
    {  
        PostOrder(p->lchild);//打印左子树  
        PostOrder(p->rchild);//打印右子树  
        printf("%c", p->data);  
    }  
}  
//层次遍历
void LevelOrder(BiTree p)  
{  
    LinkQueue q;  
    InitQueue(q);  
    BiTree pcur;  
    EnQueue(q, p);//树根入队  
    while (!IsEmpty(q))  
    {  
        DeQueue(q, pcur);//出队当前结点并打印  
        putchar(pcur->data);  
        if (pcur->lchild!= NULL)  
        {  
            EnQueue(q, pcur->lchild);//左子树入队  
        }  
        if (pcur->rchild!= NULL)  
        {  
            EnQueue(q, pcur->rchild);//右子树入队  
        }  
    }  
}  
  
int main()  
{  
    BiTree pnew;//用来指向新申请的树结点  
    BiTree tree=NULL;//tree指向树根的，代表树  
    BiElemType data;  
    ptag_t phead=NULL,ptail=NULL,list_pnew=NULL,pcur;  
    while (scanf("%c", &data))  
    {  
        if (data == '\n')  
        {  
            break;  
        }  
        //calloc申请的空间大小是2个参数的大小直接相乘，并对空间进行初始化，赋值为0(NULL)  
        pnew = (BiTree)calloc(1,sizeof(BiTNode));  
        pnew->data = data;  
        list_pnew = (ptag_t)calloc(1,sizeof(tag_t));  
        list_pnew->p = pnew;  
        //如果是树的第一个结点  
        if (tree == NULL)  
        {  
            tree = pnew;  
            phead = list_pnew;//第一个结点既是队列头，也是队列尾  
            ptail = list_pnew;  
            pcur = list_pnew;//pcur要指向要进入树的父亲元素  
        }else  
        {  
            //先让元素入列  
            ptail->pnext = list_pnew;  
            ptail = list_pnew;  
            //把接下来的结点放入树中  
            if (pcur->p->lchild == NULL)  
            {  
                pcur->p->lchild = pnew;  
            }else if (pcur->p->rchild == NULL)  
            {  
                pcur->p->rchild = pnew;  
                pcur = pcur->pnext;//放入右节点后，当前结点已满，pcur指向下一个结点  
            }  
        }  
    }  
    //先序遍历  
    PreOrder(tree);  
    printf("\n");  
    //中序遍历  
    InOrder(tree);  
    printf("\n");  
    //后序遍历  
    PostOrder(tree);  
    printf("\n");  
    //层次遍历  
    LevelOrder(tree);  
    printf("\n");  
    return 0;  
}
~~~
## 13.3 考研真题实战

### 13.3.1 真题实例

![[二叉树408真题.png]]

### 13.3.2 题目分析解题

* 树的带权路径长度(Weighted Path Length of Tree（WPL）：每个叶子结点的深度与权值之积的**总和**
* 叶子结点：没有子结点的结点（`Lchild`和`Rchild`均为空），叶子结点的深度并不相同
* 深度：结点所在层数（root结点为第一层，依次向下递增）
* 权值：结点赋给一个有着某种含义的数值
* 使用较为简单的先序遍历来定义二叉树，添加`static变量`或全局变量记录`wpl`，把每个结点的深度作为一个递归的参数来传递
	1. 若该结点是叶子结点，那么变量 wpl 加上该结点的深度与权值之积
	2. 若该结点非叶子结点，那么若左子树不为空，对左子树调用递归算法，若右子树不为空，对右子树调用递归算法，深度参数均为本结点的深度参数加一
* 最后返回计算出的 wpl 即可。
### 13.3.3 题目代码实现

~~~cpp
#include <stdio.h>  
#include <stdlib.h>  
  
typedef int BiElemType;  
  
typedef struct BiTNode{  
    BiElemType weight;//直接拿ASCII来计算即可  
    struct BiTNode *left, *right;  
}BiTNode, *BiTree;  
  
//tag结构体是辅助队列使用的  
typedef struct tag  
{  
    BiTree p;  //树的某一个结点的地址值  
    struct tag *pnext;  
}tag_t, *ptag_t;  
  
//队列的链式存储的结构体  
typedef BiTree ElemType;  
  
typedef struct LinkNode{  
    ElemType data;  
    struct LinkNode *next;  
}LinkNode;  
typedef struct{  
    LinkNode *front, *rear ;//链表头，链表尾  
}LinkQueue ;//先进先出  
  
//前序遍历  
// int wpl = 0;//全局变量，用来计算WPL  
int PreOrder(BiTree p,int deep)  
{  
    static int wpl = 0;  
    if (p!=NULL)  
    {  
        // printf("element is %c--leave is %d \n", p->weight,deep);  
        if (p->left==NULL && p->right==NULL)  
        {  
            wpl = wpl + p->weight*deep;//不是叶子结点的时候不需要算  
        }  
        PreOrder(p->left,deep+1);//打印左子树  
        PreOrder(p->right,deep+1);//打印右子树  
    }  
    return wpl;  
}  
  
  
int main()  
{  
    BiTree pnew;//用来指向新申请的树结点  
    BiTree tree=NULL;//tree指向树根的，代表树  
    BiElemType data;  
    ptag_t phead=NULL,ptail=NULL,list_pnew=NULL,pcur;  
    while (scanf("%c", &data))  
    {  
        if (data == '\n')  
        {  
            break;  
        }  
        //calloc申请的空间大小是2个参数的大小直接相乘，并对空间进行初始化，赋值为0(NULL)  
        pnew = (BiTree)calloc(1,sizeof(BiTNode));  
        pnew->weight = data;  
        list_pnew = (ptag_t)calloc(1,sizeof(tag_t));  
        list_pnew->p = pnew;  
        //如果是树的第一个结点  
        if (tree == NULL)  
        {  
            tree = pnew;  
            phead = list_pnew;//第一个结点既是队列头，也是队列尾  
            ptail = list_pnew;  
            pcur = list_pnew;//pcur要指向要进入树的父亲元素  
        }else  
        {  
            //先让元素入列  
            ptail->pnext = list_pnew;  
            ptail = list_pnew;  
            //把接下来的结点放入树中  
            if (pcur->p->left == NULL)  
            {  
                pcur->p->left = pnew;  
            }else if (pcur->p->right == NULL)  
            {  
                pcur->p->right = pnew;  
                pcur = pcur->pnext;//放入右节点后，当前结点已满，pcur指向下一个结点  
            }  
        }  
    }  
    // PreOrder(tree,1);  
    // // printf("wpl = %d\n",wpl);    printf("wpl = %d\n",PreOrder(tree,1));  
    return 0;  
}
~~~