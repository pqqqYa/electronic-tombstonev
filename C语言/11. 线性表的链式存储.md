# 11 线性表的链式存储

## 11.1 线性表的链式存储原理

* 线性表的链式存储简称链表
* 逻辑上相邻的两个元素在物理位置上不相邻

单链表节点的定义

~~~c
typedef struct LNode{    //单链表结点类型
	ElemType data;       //数据域
	struct LNode *next;  //指针域
}LNode,*LinkList;
~~~

* `typedef struct LNode`中的`LNode`不能省略，因为在结构体的内部还需要使用它来定义指针变量
* 表尾结点的指针域为`NULL`
* 可以添加头结点（考研基本都考的带头结点的题）
* 头结点：在单链表第一个结点之前附加的一个结点，为了操作上的方便
* 头指针：链表中第一个结点的存储位置，用来标识单链表

单链表的**优点**

* 插入和删除操作不需要移动元素，只需要修改指针。
* 不需要大量的连续存储空间。

单链表的**缺点**

* 单链表附加指针域，也存在浪费存储空间的缺点。（没有全部拿来存储数据）
* 查找操作时需要从表头开始遍历，依次查找，不能随机存取，


## 11.2 线性表的插入操作

插入操作

~~~c
//创建新节点q
q=(LNode*)malloc(sizeof(LNode))
q->data=x;
//在p的后面插入新节点q
q->next = p->next;
p->next = q;
//让q成为新的表尾
p->next = q;
q->next = NULL;
~~~

## 11.3 线性表的删除操作

删除操作

~~~c
p=GetElem(L,i-1);//查找删除位置的前驱节点
q = p->next;//q指向需要被删除的元素
p->next = q->next;//让被删除元素的前一个元素next指向被删除元素的后一个元素，实现断链
free(q);//释放被删除元素
~~~

##  11.4 线性表的查找操作

按序号查找结点值得算法

~~~c
//寻找第i个元素
LNode *p=L->next;
int j=1;
while(p&&j<i)
{
	p=p->next;
	j++;
}
return
;
~~~

按值查找结点的算法如下:

~~~c
LNode *p=L->next;
while(p!=NULL&&p->data!=e){
	p=p->next;
}
return p;
~~~

## 11.5 头插法新建链表

![[头插法新建链表流程图.png]]