
排序算法
* 交换类排序（冒泡排序，快速排序）
* 插入类排序
* 选择类排序
* 归并类排序

# 15.1 冒泡排序

### 15.1.1 冒泡排序的原理

冒泡排序的基本思想是：从后往前(或从前往后)两两比较相邻元素的值，(若`A[i-1]>A[j]`)，则交换它们，直到序列比较完。我们称它为第一趟冒泡，结果是将最小的元素交换到待排序列的第一个位置。关键字最小的元素如气泡一般逐渐往上“漂浮”直至“水面”。下一趟冒泡时，前一趟确定的最小元素不再参与比较，每趟冒泡的结果是把序列中的最小元素放到了序列的最终位置。最多做n-1趟冒泡就能把所有元素排好序。

![[冒泡排序演示.png]]


### 15.1.2 冒泡排序实例

随机生成10个数，先打印一次，再冒泡排序，最后再打印一次

~~~cpp
#include <stdio.h>  
#include <stdlib.h>  
#include <time.h>  
#include <string.h>  
typedef int ElemType ;  
typedef struct{  
    ElemType * elem;//整型指针  
    int TableLen;//存储动态数组里边元素的个数  
}SSTable;  
//初始化数组
void ST_Init(SSTable &ST,int len)  
{  
    ST.TableLen = len;  
    ST.elem = (ElemType*)malloc(ST.TableLen*sizeof(ElemType));  
    int i;  
    srand(time(NULL));  
    for(i=0;i<ST.TableLen;i++)  
    {  
        ST.elem[i] = rand()%100;//生成的随机数在0-99之间  
    }  
}  
//打印数组  
void ST_print(SSTable ST)  
{  
    int i;  
    for(i=1;i<ST.TableLen;i++)  
    {  
        printf("%3d",ST.elem[i]);//直接类似数组名来使用  
    }  
    printf("\n");  
}  
  
void BulleSort(ElemType *elem,int len)  
{  
    int i,j;  
    ElemType temp;  
    for(i=0;i<len-1;i++)  
    {  
        for(j=0;j<len-1-i;j++){  
            if(elem[j]>elem[j+1]){  
                temp = elem[j];  
                elem[j] = elem[j+1];  
                elem[j+1] = temp;  
            }  
        }  
    }  
}  
  
int main()  
{  
    SSTable ST;  
    ST_Init(ST,10);  
    //使用固定数组方便调试  
    ElemType A[10]={64,94,95,79,69,84,18,22,12,78};  
    //内存copy接口，当你copy整型数组，或者浮点型时，要用memcopy，不能使用strcopy，初始考到的概率很低  
    memcpy(ST.elem,A,sizeof(A));  
    ST_print(ST);  
    BulleSort(ST.elem,ST.TableLen);  
    ST_print(ST);  
    return 0;  
}
//打印结果
// 94 95 79 69 84 18 22 12 78
// 18 22 64 69 78 79 84 94 95
~~~



# 15.2 快速排序




## 15.3 插入排序





