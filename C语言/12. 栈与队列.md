# 12. 栈与队列

## 12.1 栈

### 12.1.1 栈的概念

* `stack`栈、堆栈、堆叠：先进先出（First In Last Out）
* `Top`栈顶：只允许在一端进行插入或删除操作的线性表，后来的元素作为栈顶
* `Bottom`栈底：第一个进入的元素

### 12.1.2 栈的顺序存储原理

栈是一个结构体，不是结构体指针

~~~c
typedef struct{
	Elemtype data[50];
	int top;
}SqStack;
SqStack S;
~~~

### 12.1.3 元素的出栈与入栈的原理

* 注意对top的是先移动还是后移动
* `S.top=MaxSize-1`时是栈满

~~~c
S.top=-1//栈为空
S.data[++S.top]=4//元素的入栈
x=S.data[S.top--]//元素的出栈
~~~

### 12.1.4 栈的链式存储原理

链栈的实现与链表的实现一致，详见链表章节（几乎不考）

* 元素的入栈=链表头插法
* 元素的出栈=删除第一个元素
* `L->next == NULL`栈为空

### 12.1.5 栈的初始化、出入栈，读取栈顶元素实现

~~~c
#include <stdio.h>  
#include <stdlib.h>  
  
#define MaxSize 50  //限定数组大小
typedef int ElemType;  
  
typedef struct {  
    ElemType data[MaxSize];//数组  
    int top;  
} SqStack;  
//初始化栈  
void InitStack(SqStack &S)  
{  
    S.top = -1;//代表栈为空  
}  
//判断栈是否为空  
bool StackEmpty(SqStack &S)  
{  
    if (S.top == -1)  
    {  
        return true;  
    }  
    else  
    {  
        return false;  
    }  
}  
//入栈  
bool Push(SqStack &S, int x)  
{  
    if (S.top == MaxSize - 1)//数组的大小不能改变，，避免越界  
    {  
        return false;  
    }  
    S.data[++S.top] = x;  
    return true;  
}  
//出栈  
bool Pop(SqStack &S, int &x)  
{  
    if (S.top == -1)  
    {  
        return false;  
    }  
    x = S.data[S.top--];//后减减，x=S.data[S.top];S.top=S.top-1;  
    return true;  
}  
//读取栈顶元素  
bool GetTop(SqStack &S, int &x)  
{  
    if (S.top == -1)//说明栈为空  
    {  
        return false;  
    }  
    x = S.data[S.top];  
    return true;  
}  
  
int main()  
{  
    SqStack S;//先进后出 FILO LIFO    bool flag;//用来判断操作是否成功  
    ElemType m;//用来存放拿出的元素  
    InitStack(S);//初始化  
    //判断栈是否为空  
    flag = StackEmpty(S);  
    if(flag)  
    {  
        printf("栈是空的\n");  
    }  
    //入栈，获取栈顶元素  
    Push(S,3);//入栈元素 3    Push(S,4);//入栈元素 4    Push(S,5);//入栈元素 5    flag=GetTop(S,m);//获取栈顶元素  
    if(flag)  
    {  
        printf("获取栈顶元素为 %dwn",m);  
    }  
    //出栈  
    flag=Pop(S,m);//弹出栈顶元素  
    if(flag)  
    {  
        printf("弹出元素为 %dwn",m);  
    }  
    return 0;  
}
~~~

## 12.2 队列

### 12.2.1 队列的原理

* `Queue`队列，简称队，只允许在一端进行插入，而在表的另一端进行删除。First In First Out
* **入队**（进队）向队列中插入元素
* **出队**（离队）删除元素
* `Front`队头允许删除的一端，称之为队首
* `Rear`队尾允许插入的一端

### 12.2.2 队列的链式表示的原理

* 队列的链式表示称为链队列
* 一个同时带有队头指针和队尾指针的单链表。
* 头指针指向队头结点，尾指针指向队尾结点，即单链表的最后一个结点

~~~c
typedef int ElemType,
typedef struct LinkNode{
	ElemType data;
	struct LinkNode *next;
}LinkNode;//链表结点的结构体
typedef struct{
	LinkNode *front,*rear;//链表头 链表尾
}LinkQueue;//先进先出
LinkQueue Q:
~~~

相当于原有的链表编写添加了链头链尾

## 12.3 循环队列

### 12.3.1 循环队列的原理

* **注意**循环队列存储的是`MaxSize-1`个元素，防止分不清为空或为满
* `Q.front == Q.rear`相同表示循环队列为空
* `(Q.front + 1) % MaxSize == Q.rear`表示循环队列队满
* `Q.rear`指向的是最后一个元素之后的位置

~~~c
#define MaxSize 5
typedef int ElemType,
typedef struct{
	ElemType data[MaxSize];//数组,存储MaxSize-1个元素
	int front,rear;//队列头 队列尾
}SqQueue,
SqQueue Q;
~~~

![[循环队列流程.png]]

### 12.3.2 循环队列的入队原理

~~~c
#define MaxSize 5
bool EnQueue(SqQueue &Q,ElemType x)
{
	if((Q.rear+1)%MaxSize==Q.front)//判浙是否队满
	{
		return false;
	}
	Q.data[Q.rear]=x;//放入元素
	Q.rear=(Q.rear+1)%MaxSize;//改变队尾标记
	return true;
}
~~~

### 12.3.3 循环队列的出队原理

~~~c
bool DeQueue(SqQueue &Q,ElemType &x)
{
	if(Q.rear==Q.front)
	{
		return false;
	}                         
	x=Q.data[Q.front];//先进先出
	Q.front=(Q.front+1)%MaxSize;
	return true,
}
~~~

### 12.3.4 循环队列的代码实现