# ![](附件/软件测试考试内容.svg)1. 软件测试的基本原则

1. 所有的软件测试都应追溯到用户需求
2. 尽早地和不断地进行软件测试
3. 不可能完全地测试
4. 增量测试，由小到大
5. 避免测试自己的程序
6. 设计充分完善的测试用例
	- 完善的测试用例
	- 完善的测试用例集
7. 注意测试中的群集现象
8. 确认缺编的有效性
9. 合理安排测试计划
10. 进行回归测试
	- 测试测试用例地维护
	- 缺陷之间地关联性
11. 测试结果地统计、分析和可视化
12. 及时更新测试

# 2. 软件测试的概念
## 2.1 TDD测试驱动开发

- Test - Driven Development一种软件开发方法
- 强调在编写实际功能代码之前，先编写测试用例来描述软件功能的预期行为。
- 测试先行

## 2.2 软件测试的分类

- 从自动化的角度分类
    - 自动化测试
    - 人工测试
- 从测试阶段角度分类
    - 单元测试
    - 集成测试
    - 系统测试
    - 验收测试
- 从技术角度分类
    - 黑盒测试
    - 白盒测试
    - 灰盒测试
# 3. 软件测试的方法

## 3.1 静态测试

- 不在计算机上实际执行所测试的软件而进行的测试（区别于动态测试）
- 包含各种对需求规约、分析和设计规约、代码及开发过程中的各种文档的检查，静态结构分析等
- 可借助软件工具自动进行
- 成本更低，效率更高，可在软件开发生命周期早期阶段发现软件的缺陷。

## 3.2 动态测试

- 黑盒测试技术
- 白盒测试技术
- 灰盒测试技术

## 3.3 黑盒测试

- 功能测试或数据驱动测试
- 完全不考虑程序内部的逻辑结构和内部特性，只依据软件的需求规格说明书，检查程序的功能是否符合它的功能说明。

### 3.3.1 黑盒测试有哪些

1. 边界值分析法
2. 等价类测试法
3. 错误推测法
4. 因果图法
5. 决策表测试法
6. UseCase法（场景法）
7. 正交实验法

### 3.3.2 等价类测试法

- 等价类：将输入数据域划分成若干个子集（等价类），然后从每个子集中选取少数具有代表性的数据作为测试用例。
- 一般：不考虑输入数据之间的相互关系，只关注单个输入数据的有效和无效取值范围所划分出来的等价类。
- 弱/强：单/多缺陷假设（单个输入数据出错/多个数据输入错误）
- 健壮：考虑了无效值（无效等价类），是否能对无效数据处理，评价在面对无效输入时的处理能力

合成

1. 弱一般等价类
2. 强一般等价类
3. 弱健壮等价类
4. 强健壮等价类

## 3.4 白盒测试

针对被测程序的源代码，测试者可以完全不考虑程序的功能，所以，**如果需求规约中的功能没有实现，那么白盒测试很难发现**。

### 3.4.1 白盒测试有哪些

1. 代码检查法
2. 静态结构分析法
3. 静态质量度量法
4. **逻辑覆盖法**
5. 基本路径测试法
6. 域测试
7. 符号测试
8. Z 路径覆盖
9. 程序变异以及程序控制流分析
10. 数据流分析

### 3.4.2 基本概念

流图：程序流程图简化为控制流图，简称流图![](附件/程序流程图转化为控制流程图.jpg)


环形复杂度（圈复杂度）

- 衡量程序逻辑复杂度。
- 基本路径方法：提供程序基本集的独立路径数量和确保所有语句至少执行一次的测试数量上界。
- 独立路径：程序中至少引入一个新的处理语句集合或一个新条件的程序通路，它必须至少包含一条在本次定义路径之前不曾用过的边。
- 路径：表示程序通路的节点序列表示，也可用弧线表示。
- 程序越复杂，路径数越多。
- 为了使程序图成为强连通图，从图的入口点到出口点加一条用线表示的有向边，使图成为强连通图。

复杂度计算

1. 复杂度$V(G)$计算公式：$V(G_1) = e-n+p$
	- 需修改控制流图，每一个结束点都增加一个到启始点的边，形成强连通图
	- e：边数（弧的个数）
	- n：节点数
	- p：连通分量的个数（常为1）
	- ==强连通图==的复杂度V(G) = 线性独立环路的数量（ 图中被划分的区域的数量）
2. 复杂度$V(G)$计算公式：$V(G_2) = e-n+2p$
	- e：边数（弧的个数）
	- n：节点数
	- p：连通分量的个数（常为1）

### 3.4.3 逻辑覆盖--逻辑覆盖标准

1. **语句覆盖**：最基本的覆盖标准，使得每一条可执行语句至少被执行一次
2. **判定覆盖**（分支覆盖）：使得每个判定的所有可能结果（T/F）至少出现一次。
3. **条件覆盖**：==使得判定中的每个条件的所有可能结果至少出现一次==
4. **判定/条件覆盖**：使得判定中每个条件的所有可能结果至少出现一次，并且每个判定本身的所有可能结果也至少出现一次
5. **条件组合覆盖**：使得每个判定中条件结果的所有可能组合都至少出现一次
6. **点覆盖**：覆盖流图中的所有节点
7. **边覆盖**：覆盖流图中的所有边
8. **路径覆盖**：使得程序的所有可能执行路径都至少被执行一次


## 3.5 灰盒测试

对软件的部分内部结构有一定了解，但不像白盒测试那样深入到每一行代码，侧重于功能验证的同时，也会利用部分内部信息来指导测试用例的设计，关注软件的功能和结构之间的交互，以及这些交互如何影响软件的外部行为1。



# 4. 软件开发阶段

- 项目规划阶段
- 需求阶段（==在本阶段同步开启软件测试==）
- 详细设计与概要设计阶段
- 编码阶段
- 软件测试阶段
	- **α测试**：在内部进行，由开发人员和测试人员共同参与，目的是在软件发布给外部用户之前，对软件的功能、性能、稳定性等方面进行全面的检查。
	- **β测试**：将软件发布给外部的部分用户进行的测试，目的是获取外部用户对软件的反馈，进一步发现软件在实际使用环境中可能出现的问题。
- 维护阶段

## 4.1 软件测试阶段内容

1. 规格说明书审查
2. 系统和程序设计审查
3. 单元测试：对用源代码实现的每一个程序单元进行测试，检查各个程序模块是否正确地实现了规定的功能。
4. 集成测试：将已测试过的模块组装起来，主要对与设计相关的软件体系结构的构造进行测试。
5. 确认测试：检查已实现的软件是否满足了需求规格说明中确定了的各种需求以及软件配置是否完全、正确。
6. 系统测试：把已经经过确认的软件纳入实际运行环境中，与其它系统成份组合在一起进行测试。
7. 验收测试：检验软件产品的最后一道工序，主要突出用户的作用，同时软件开发人员也应有一定的程度参与。



# 5. 软件测试的4个级别

## 5.1 单元测试（模块测试）


- 有谁来执行：程序员
- 什么时候执行：开发人员在编写代码的同时编写单元测试用例

- 针对的是软件设计的最小单位，程序模块
- 多个模块可以平行地独立进行单元测试
- 白盒测试用例为主，黑盒为辅

## 5.2 集成测试

### 5.2.1 集成模式

* 一次性集成测试模式：先按模块分别测试，再全部组装后全量测试。
* 增量式集成测试模式（渐增式集成）：首先按模块进行测试，再将测试后地模块组装上，实现一边模块测试，一边组装模块，直到最后完成全量测试。

### 5.2.2 集成方法（增量式集成测试的2种方法）

1. 自顶向下集成
2. 自底向上集成
3. 混合集成
### 5.2.3 持续集成
### 5.2.4 回归测试

## 5.3 系统测试

## 5.4 验收阶段

# 6. App应用测试

# 7.  微服务架构应用测试

# 8. 嵌入式系统测试

# 9. 代码

## 9.1 Junit

断言（assert）方法

## 9.2 Selenium

- 导入对应的包
- 打开网站
- web自动化测试（进行一些简单的操作）
